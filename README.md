# ğŸŒŸ 160 Days of DSA with GeeksforGeeks ğŸš€  

[![DSA Progress](https://img.shields.io/badge/DSA-Progress-green)](#)  
[![Languages](https://img.shields.io/badge/Language-Java-blue)](#)
[![License](https://img.shields.io/github/license/amitkumardemo/160-days-of-dsa)](#)

---

## ğŸ“Œ **Overview**

Welcome to the **160 Days of DSA Challenge** repository! This is a collection of my solutions to GeeksforGeeks DSA problems following their **160-day structured roadmap**. The aim is to build a solid foundation in **Data Structures and Algorithms (DSA)** while preparing for competitive programming and technical interviews.

---

## ğŸ› ï¸ **Tools Required**

- **Programming Language**: Java 
- **IDE**: VS Code, IntelliJ IDEA, GFG Code Editor 
- **Account on [GeeksforGeeks](https://www.geeksforgeeks.org/user/lbgofficicwfy/)** for problem statements  

---

## ğŸ—ºï¸ **Roadmap**

| **Phase**          | **Topics Covered**                        | **Timeline**       |  
|---------------------|-------------------------------------------|--------------------|  
| **Phase 1**        | Arrays: Lay the Foundation                | Days 1â€“13          |  
| **Phase 2**        | Strings: Master Text Processing           | Days 14â€“20         |  
| **Phase 3**        | Sorting: Organize Data Efficiently        | Days 21â€“27         |  
| **Phase 4**        | Searching: Find What You Need Fast        | Days 28â€“35         |  
| **Phase 5**        | Matrix: Unlock the Power of 2D Data       | Days 36â€“41         |  
| **Phase 6**        | Hashing: Unlock Data Relationships        | Days 42â€“49         |  
| **Phase 7**        | Two Pointer Technique: Simplify Problems  | Days 50â€“61         |  
| **Phase 8**        | Prefix Sum: Solve Cumulative Problems     | Days 62â€“66         |  
| **Phase 9**        | Linked List: Manage Dynamic Data          | Days 67â€“76         |  
| **Phase 10**       | Backtracking: Recursive Problem-Solving   | Days 77â€“79         |  
| **Phase 11**       | Trees: Build and Traverse Hierarchical Data | Days 80â€“92       |  
| **Phase 12**       | Heap: Manage Prioritized Data             | Days 93â€“96         |  
| **Phase 13**       | Stack: Simplify Operations                | Days 97â€“105        |  
| **Phase 14**       | Queue and Deque: FIFO Operations          | Days 106â€“107       |  
| **Phase 15**       | Dynamic Programming (DP): Optimize Problems | Days 108â€“133    |  
| **Phase 16**       | Greedy: Make Optimal Choices              | Days 134â€“137       |  
| **Phase 17**       | Graphs: Explore Connectivity and Paths    | Days 138â€“152       |  
| **Phase 18**       | Tries: Explore Prefix Trees               | Days 153â€“155       |  
| **Phase 19**       | Bit Manipulation: Simplify Binary Operations | Days 156â€“160   |  
  

---
# Progress Tracker: GeeksforGeeks GfG 160 Series

This repository tracks my progress in solving problems from the GeeksforGeeks GfG 160 series. Below is a log of the problems solved, with brief descriptions of the approaches used and the learning outcomes.

## ğŸ“ˆ **Progress Tracker**

| **Day** | **Topic**                                     | **Problems Solved**                      | **Notes/Comments**                                                                                        |
|---------|-----------------------------------------------|------------------------------------------|-----------------------------------------------------------------------------------------------------------|
| 1       | GfG 160 - Second Largest                      | Day_1_Second_Largest                     | Solved the problem of finding the second largest element in an array.                                      |
| 2       | GfG 160 - Move Zeros to End                   | Day_2_Move_All_Zeroes_to_End             | Implemented moving all zeroes to the end of the array without changing the relative order of other elements.|
| 3       | GfG 160 - Reverse Array                       | Day_3_Reverse_an_Array                   | Reversed the array in-place without using extra space.                                                     |
| 4       | GfG 160 - Rotate Array                        | Day_4_Rotate_Array                       | Learned and implemented array rotation by `d` elements, utilizing an efficient O(n) approach.              |
| 5       | GfG 160 - Next Permutation                     | Day_5_Next_Permutation                    | Implemented next lexicographical permutation of an array using a systematic approach.                     |
| 6       | GfG 160 - Majority Element II                 | Day_6_Majority_Element_II                | Identified elements appearing more than `n/3` times in an array using the Boyer-Moore Voting Algorithm.    |
| 7       | GfG 160 - Stock Buy and Sell â€“ Multiple Transaction Allowed | Day_7_Stock_Buy_and_Sell_Multiple_Transaction_Allowed | Maximized profit by performing multiple buy and sell operations using a greedy approach.                    |
| 8       | GfG 160 - Stock Buy and Sell â€“ Max One Transaction Allowed | Day_8_Stock_Buy_and_Sell_Max_One_Transaction_Allowed | Implemented a solution to maximize profit with at most one buy and sell transaction using dynamic programming. |
|9 | GFG 160 - Minimize the Heights II | Day_9_Minimize the Heights II | Find out the minimum possible difference between the height of the shortest and tallest towers after you have modified each tower.|
|10 | GFG 160 - Kadane's Algorithm | Day_10_Kadane's Algorithm | Given an integer array arr[]. You need to find and return the maximum sum possible from all the subarrays.|
|11| GFG 160 - Maximum Product Subarray | Day_11_Maximum Product Subarray | Given an array arr[] that contains positive and negative integers (may contain 0 as well). Find the maximum product that we can get in a subarray of arr.|
|12| GFG - 160 - Max Circular Subarray Sum | Day_12_Max Circular Subarray Sum |Given an array of integers arr[] in a circular fashion. Find the maximum subarray sum that we can get if we assume the array to be circular.| 







---

## âœ¨ **Key Learning Outcomes**

- **Array Manipulation:** Enhanced skills in rotating, reversing, and performing efficient operations on arrays.
- **Algorithm Design:** Focused on algorithms such as Boyer-Moore for majority element identification and greedy approaches for stock trading problems.
- **Dynamic Programming:** Applied dynamic programming to problems like the stock trading with one transaction allowed.

---

## ğŸ“œ **About GfG 160 Series**

The GfG 160 Series is a collection of problems curated by GeeksforGeeks, designed to improve problem-solving skills in algorithms and data structures. Each problem is tackled systematically to build a deeper understanding of core concepts and their applications.

Feel free to check out my progress and solutions for each of these problems in the individual files for more in-depth details and code snippets.

                    




â¡ï¸ **[View Full Progress](https://www.geeksforgeeks.org/user/lbgofficicwfy/)**

---

## ğŸ¤ **Contributing**

Contributions are welcome! Here's how you can help:  
1. Fork the repository.  
2. Clone your forked repo.  
3. Create a new branch for your changes.  
4. Commit your code with clear messages.  
5. Submit a pull request.  

---



## ğŸ“¬ **Connect With Me**

Feel free to connect for discussions or collaboration:  
- ğŸŒ [LinkedIn](https://www.linkedin.com/in/amit-kumar-686196225/)  
- ğŸ“§ Email: [youremail@example.com](mailto:amitk25783@gmail.com)  

---

> **â€œConsistency is the key to success. Letâ€™s tackle DSA one problem at a time!â€** ğŸŒŸ
